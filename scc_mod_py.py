# -*- coding: utf-8 -*-
"""scc_mod.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aHZG1TibzBg9kl7l6MZSw3lA2ND1V7s2
"""

import csv
import random
from language_model.py import *
from operator import itemgetter

class question(language_model):
    
    def __init__(self,aline):
        self.fields=aline
    
    def get_field(self,field):
        return self.fields[question.colnames[field]]
    
    def add_answer(self,fields):
        self.answer=fields[1]
   
    def chooseA(self):
        return("a")

    def get_left_context(sent_tokens,window = 1, target = "_____"):
      """Get words preceeding a target word"""
      
      found=-1

      for i,token in enumerate(sent_tokens):
        if token == target:
            found = i
            break
        if found >-1:
          return sent_tokens[i-window: i]
        else: 
          return []

    def get_right_context(sent_tokens,window = 1, target = "_____"):
      """Get words preceeding a target word"""
      
      found=-1

      for i,token in enumerate(sent_tokens):
        if token == target:
            found = i
            break
        if found >-1:
          return sent_tokens[i: window+i]
        else: 
          return []

    
    def predict(self,method="chooseA"):
      choice = ["a","b","c","d"]
        #eventually there will be lots of methods to choose from
      if method=="chooseA":
          return self.chooseA()
      elif method == "random": 
        number = random.randint(0,3)
        return choice[number]
      elif method == "unigram":
          probs = [(option, language_model.unigram(option)) for option in choice]     
          return sorted(probs, operator = itemgetter(1), reverse = True)[0][0]
      elif method == "bigram_l":
          probs = [(option, self.bigram(self.get_left_context, option )) for option in choice ]
          return sorted(probs, operator = itemgetter(1), reverse = True)[0][0]
      elif method == "bigram_r":
          probs = [(option, self.bigram(option, self.get_right_context_1)) for option in choice]
          return sorted(probs, operator = itemgetter(1), reverse = True)[0][0]
      elif method == "bigram":
          probs = [(option, self.bigram(option, self.get_right_context) * self.bigram(self.get_left_context, option)) for option in choice ]
          return sorted(probs, operator = itemgetter(1), reverse = True)[0][0]

#Create triagrams in language model and get scc_mod working 


    def predict_and_score(self,method="chooseA"):
        
        #compare prediction according to method with the correct answer
        #return 1 or 0 accordingly
        prediction=self.predict(method=method)
        if prediction ==self.answer:
            return 1
        else:
            return 0

class scc_reader:
    
    def __init__(self,qs=questions,ans=answers):
        self.qs=qs
        self.ans=ans
        self.read_files()
        
    def read_files(self):
        
        #read in the question file
        with open(self.qs) as instream:
            csvreader=csv.reader(instream)
            qlines=list(csvreader)
        
        #store the column names as a reverse index so they can be used to reference parts of the question
        question.colnames={item:i for i,item in enumerate(qlines[0])}
        
        #create a question instance for each line of the file (other than heading line)
        self.questions=[question(qline) for qline in qlines[1:]]
        
        #read in the answer file
        with open(self.ans) as instream:
            csvreader=csv.reader(instream)
            alines=list(csvreader)
            
        #add answers to questions so predictions can be checked    
        for q,aline in zip(self.questions,alines[1:]):
            q.add_answer(aline)
        
    def get_field(self,field):
        return [q.get_field(field) for q in self.questions] 
    
    def predict(self,method="chooseA"):
        return [q.predict(method=method) for q in self.questions]
    
    def predict_and_score(self,method="chooseA"):
        scores=[q.predict_and_score(method=method) for q in self.questions]
        return sum(scores)/len(scores)

